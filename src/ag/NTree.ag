PRAGMA genlinepragmas

imports{
-- libraries
import Data.List
--import qualified Data.Map as Map
import Data.Maybe
import Data.Function
import Data.Char

-- datatypes
import DataTreeHTML
import DataTreeCSS
import CSSParser (parseStyleString, parseStyleInline)
import PropertyValue
import PropertiesCSS
import FSBox
import FSTreeFase1
import NumRomans
}

INCLUDE "DataTreeHTML.ag"
INCLUDE "GetStyleSheets.ag"
INCLUDE "MatchSelector.ag"
INCLUDE "DoSpecifiedValue.ag"
INCLUDE "DoComputedValue.ag"
INCLUDE "CounterProcess.ag"
INCLUDE "GeneratedContent.ag"

-- uploading the name of a node
ATTR Node [|| name: String ]
SEM Node
    | NText lhs.name = "text"
    | NTag  lhs.name = @name

-- Generating the Formatting Structure of a web page
ATTR NTrees [|| fstrees:{[Maybe BoxTree]}]
SEM NTrees
    | Cons lhs.fstrees = @hd.fstree : @tl.fstrees
    | Nil  lhs.fstrees = []
            
ATTR Root NTree [|| fstree: {Maybe BoxTree}]
SEM NTree
    | NTree lhs.fstree 
                = let boxesBefore = generateBoxContent (fst @loc.computedContentValueProps) @loc.computedValueProps (fst @loc.myCounterScope) @loc.myQuoteScope
                      boxesAfter  = generateBoxContent (snd @loc.computedContentValueProps) @loc.computedValueProps (fst @loc.myCounterScope) @loc.myQuoteScope
                      boxes       = let before   = map applyWhiteSpaceProperty $ catMaybes boxesBefore
                                        children = map applyWhiteSpaceProperty $ catMaybes @ntrees.fstrees
                                        after    = map applyWhiteSpaceProperty $ catMaybes boxesAfter
                                    in catMaybes $ before ++ children ++ after
                  in case @node.myself of
                       NTag nm iamreplaced attrs
                            -> case computedValue (@loc.computedValueProps Map.! "display") of
                                    KeyValue "none"      
                                        -> Nothing
                                    KeyValue "list-item" 
                                        -> let listGrouped = groupBy funGroupCompare boxes
                                               listBCnt    = map (toBoxContainer @lhs.iamtheroot @loc.computedValueProps Nothing) listGrouped
                                           in Just $ BoxItemContainer @loc.computedValueProps attrs listBCnt
                                    KeyValue "inline"    
                                        -> if iamreplaced
                                           then Just $ BoxContainer @node.name "inline" @loc.computedValueProps iamreplaced attrs []
                                           else let (bool,str) = doIContainOnlyText boxes
                                                in if bool
                                                then Just $ BoxText @loc.computedValueProps attrs str
                                                else Just $ BoxContainer @node.name "inline" @loc.computedValueProps iamreplaced attrs boxes
                                    KeyValue "block"     
                                        -> if iamreplaced
                                           then Just $ BoxContainer @node.name "inline" @loc.computedValueProps iamreplaced attrs []
                                           else if any isThereBlockDisplay boxes
                                                then let listGrouped = groupBy funGroupCompare boxes
                                                         listBCnt    = map (toBoxContainer @lhs.iamtheroot @loc.computedValueProps Nothing) listGrouped
                                                     in Just $ BoxContainer @node.name "block" @loc.computedValueProps iamreplaced attrs listBCnt
                                                else Just $ BoxContainer @node.name "inline" @loc.computedValueProps iamreplaced attrs boxes
                       NText str   -- a simple text is never affected by an style rule
                            -> Just $ BoxText @loc.computedValueProps Map.empty str     -- his container will apply the white-space property

-- auxiliar functions
{
-- data type instances
instance Eq Node where
    NTag n1 _ _ == NTag n2 _ _ = n1 == n2
    _           == _           = False

applyWhiteSpaceProperty (BoxText props attrs str)
    = let whitespace = computedValue $ props Map.! "white-space"
      in case whitespace of
            KeyValue "normal"   -> let res = processString True  True  str in if null res then Nothing else Just (BoxText props attrs res)
            KeyValue "nowrap"   -> let res = processString True  True  str in if null res then Nothing else Just (BoxText props attrs res)
            KeyValue "pre-line" -> let res = processString True  False str in if null res then Nothing else Just (BoxText props attrs res)
            KeyValue "pre"      -> let res = processString False False str in if null res then Nothing else Just (BoxText props attrs res)
            KeyValue "pre-wrap" -> let res = processString False False str in if null res then Nothing else Just (BoxText props attrs res)
            KeyValue "inherit"  -> error "[NTree] unexpected inherit value at applyWhyteSpaceProperty."
    where processString isSpaceCollapsed isLineFeedIgnored input
              = case (isSpaceCollapsed, isLineFeedIgnored) of
                    (True , True ) -> unwords . words $ input                               -- case of normal and nowrap
                    (True , False) -> unlines . map unwords . map words . lines $ input     -- case of pre-line
                    otherwise      -> input                                                 -- case of pre and pre-wrap
applyWhiteSpaceProperty another
    = Just another

doIContainOnlyText [BoxText _ _ str] = (True ,str)
doIContainOnlyText _                 = (False,"error")

getAttributes (NTag _ _ ats) = ats
getAttributes _              = Map.empty

isThereBlockDisplay bx
    = case bx of
        BoxItemContainer       _ _ _ -> True
        BoxContainer _ _ props _ _ _ -> verifyProperty "display" "block" props
        BoxText          props _ _   -> verifyProperty "display" "block" props

-- This function build a group just for display=inline, and the others is a list of one element
funGroupCompare = (&&) `on` (\bx -> verifyProperty "display" "inline" (getProps bx))
    where getProps bx 
            = case bx of
                BoxItemContainer props _ _   -> props
                BoxContainer _ _ props _ _ _ -> props
                BoxText          props _ _   -> props

-- function that transform an inline element into a block container
toBoxContainer iamtheroot sprops iamreplaced lst@(bx:bxs) 
    = case bx of
        BoxItemContainer        _ _ _ -> bx
        BoxContainer nm _ props _ _ _ -> if verifyProperty "display" "block" props
                                         then bx
                                         else BoxContainer (nm++"?") "inline" (applyInheritance iamtheroot propertiesCSS sprops iamreplaced) False Map.empty lst
        BoxText            props _  _ -> if verifyProperty "display" "block" props
                                         then bx
                                         else BoxContainer "Â¿?" "inline" (applyInheritance iamtheroot propertiesCSS sprops iamreplaced) False Map.empty lst

-- this function build the specified value and the computed value
applyInheritance iamtheroot listProps fatherProps iamreplaced = 
    let inhprops              = Map.fromList (map fun listProps)
        mapWithSpecifiedValue = Map.adjust (\_ -> keyValue "block") "display" inhprops
    in Map.mapWithKey (doComputedValue iamtheroot fatherProps mapWithSpecifiedValue iamreplaced False) mapWithSpecifiedValue
    where fun (nm,inh,def) = if inh
                             then (nm, fatherProps Map.! nm)
                             else (nm, def)

}

