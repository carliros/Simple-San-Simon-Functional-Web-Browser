PRAGMA genlinepragmas

imports{
-- libraries
import Data.List
import qualified Data.Map as Map
import Data.Maybe
import Data.Function

-- datatypes
import CSSParser (parseStyleString, parseStyleInline)
import PropertyValue
import PropertiesCSS
import DataTreeCSS
import FSBox
import FSTreeFase1
import NumRomans
}

INCLUDE "DataTreeHTML.ag"
INCLUDE "GetStyleSheets.ag"
INCLUDE "MatchSelector.ag"
INCLUDE "DoSpecifiedValue.ag"
INCLUDE "DoComputedValue.ag"
INCLUDE "CounterProcess.ag"

-- Generating the Formatting Structure of a web page
ATTR NTrees [|| fstrees:{[Maybe BoxTree]}]
SEM NTrees
    | Cons lhs.fstrees = @hd.fstree : @tl.fstrees
    | Nil  lhs.fstrees = []
            
ATTR Root NTree [|| fstree: {Maybe BoxTree}]
SEM NTree
    | NTree lhs.fstree 
                = let boxesBefore = generateBoxContent (fst @loc.computedContentValueProps) @loc.computedValueProps (fst @loc.myCounterScope) @loc.myQuoteScope
                      boxesAfter  = generateBoxContent (snd @loc.computedContentValueProps) @loc.computedValueProps (fst @loc.myCounterScope) @loc.myQuoteScope
                      boxes       = catMaybes $ boxesBefore ++ @ntrees.fstrees ++ boxesAfter
                  in case @node.myself of
                       NTag nm iamreplaced attrs
                            -> case computedValue (@loc.computedValueProps Map.! "display") of
                                    KeyValue "none"      
                                        -> Nothing
                                    KeyValue "list-item" 
                                        -> let listGrouped = groupBy funGroupCompare boxes
                                               listBCnt    = map (toBoxContainer @lhs.iamtheroot @loc.computedValueProps Nothing) listGrouped
                                           in Just $ BoxItemContainer @loc.computedValueProps attrs listBCnt
                                    KeyValue "inline"    
                                        -> if iamreplaced
                                           then Just $ BoxContainer "inline" @loc.computedValueProps iamreplaced attrs []
                                           else let (bool,str) = doIContainOnlyText boxes
                                                in if bool
                                                then Just $ BoxText @loc.computedValueProps attrs str
                                                else Just $ BoxContainer "inline" @loc.computedValueProps iamreplaced attrs boxes
                                    KeyValue "block"     
                                        -> if iamreplaced
                                           then Just $ BoxContainer "inline" @loc.computedValueProps iamreplaced attrs []
                                           else if any isThereBlockDisplay boxes
                                                then let listGrouped = groupBy funGroupCompare boxes
                                                         listBCnt    = map (toBoxContainer @lhs.iamtheroot @loc.computedValueProps Nothing) listGrouped
                                                     in Just $ BoxContainer "block" @loc.computedValueProps iamreplaced attrs listBCnt
                                                else Just $ BoxContainer "inline" @loc.computedValueProps iamreplaced attrs boxes
                       NText str   -- a simple text is never affected by an style rule
                            -> Just $ BoxText @loc.computedValueProps Map.empty str

-- Generating the Tree-Box Formatting Structure
ATTR NTrees [|| outbox:{[Maybe FSBox]}]
SEM NTrees
    | Cons lhs.outbox = @hd.outbox : @tl.outbox
    | Nil  lhs.outbox = []

ATTR NTree [|| outbox: {Maybe FSBox} ]
SEM NTree
    | NTree lhs.outbox = case @node.myself of
                            NTag  str _ _ -> if verifyProperty "display" "none" @loc.computedValueProps
                                             then Nothing
                                             else Just $ FSBox str @loc.computedValueProps (catMaybes @ntrees.outbox)
                            NText str     -> if verifyProperty "display" "none" @loc.computedValueProps
                                             then Nothing
                                             else Just $ FSBox "text" @loc.computedValueProps []

ATTR Root [|| outbox: FSBox ]
SEM Root
    | Root lhs.outbox = fromJust @ntree.outbox


-- auxiliar functions
{
generateBoxContent props srcProps counterScope (open,close)
    = case computedValue (props Map.! "content") of
            ListValue list    -> genBoxes list
            KeyValue "none"   -> [Nothing]
            KeyValue "normal" -> [Nothing]
    where getQuote lst
            = let depth = open - close
                  len   = length lst
              in if ((depth >= 1) && (depth <= len))
                 then Just $ lst !! (depth - 1)
                 else if depth > len
                      then Just $ last lst
                      else Nothing
          genBoxes []
            = []
          genBoxes (e:es) 
            = case e of
                StringValue str           -> (Just $ BoxText props Map.empty str) : genBoxes es
                Counter key style         -> if Map.member key counterScope
                                             then case style of
                                                    Nothing 
                                                        -> let value = show $ getHead $ counterScope Map.! key
                                                           in (Just $ BoxText props Map.empty value) : genBoxes es
                                                    Just val 
                                                        -> case val of
                                                                KeyValue "none"
                                                                    -> genBoxes es
                                                                KeyValue "disc"
                                                                    -> let attrs = Map.singleton "src" "disc.png"
                                                                       in (Just $ BoxContainer "inline" props True attrs []) : genBoxes es
                                                                KeyValue "circle"
                                                                    -> let attrs = Map.singleton "src" "circle.png"
                                                                       in (Just $ BoxContainer "inline" props True attrs []) : genBoxes es
                                                                KeyValue "square"
                                                                    -> let attrs = Map.singleton "src" "square.png"
                                                                       in (Just $ BoxContainer "inline" props True attrs []) : genBoxes es
                                                                KeyValue "decimal"
                                                                    -> let value = show $ getHead $ counterScope Map.! key
                                                                       in (Just $ BoxText props Map.empty value) : genBoxes es
                                                                KeyValue "lower-roman"
                                                                    -> let value = toRomanLower $ getHead $ counterScope Map.! key
                                                                       in (Just $ BoxText props Map.empty value) : genBoxes es
                                                                KeyValue "upper-roman"
                                                                    -> let value = toRomanUpper $ getHead $ counterScope Map.! key
                                                                       in (Just $ BoxText props Map.empty value) : genBoxes es
                                             else genBoxes es
                Counters key sep style    -> if Map.member key counterScope
                                             then case style of
                                                    Nothing 
                                                        -> let value = reverse $ concat $ intersperse sep $ mapScope show $ counterScope Map.! key
                                                           in (Just $ BoxText props Map.empty value) : genBoxes es
                                                    Just val 
                                                        -> case val of
                                                                KeyValue "none"
                                                                    -> genBoxes es
                                                                KeyValue "disc"
                                                                    -> let attrs = Map.singleton "src" "disc.png"
                                                                       in (Just $ BoxContainer "inline" props True attrs []) : genBoxes es
                                                                KeyValue "circle"
                                                                    -> let attrs = Map.singleton "src" "circle.png"
                                                                       in (Just $ BoxContainer "inline" props True attrs []) : genBoxes es
                                                                KeyValue "square"
                                                                    -> let attrs = Map.singleton "src" "square.png"
                                                                       in (Just $ BoxContainer "inline" props True attrs []) : genBoxes es
                                                                KeyValue "decimal"
                                                                    -> let value = reverse $ concat $ intersperse sep $ mapScope show $ counterScope Map.! key
                                                                       in (Just $ BoxText props Map.empty value) : genBoxes es
                                                                KeyValue "lower-roman"
                                                                    -> let value = reverse $ concat $ intersperse sep $ mapScope toRomanLower $ counterScope Map.! key
                                                                       in (Just $ BoxText props Map.empty value) : genBoxes es
                                                                KeyValue "upper-roman"
                                                                    -> let value = reverse $ concat $ intersperse sep $ mapScope toRomanUpper $ counterScope Map.! key
                                                                       in (Just $ BoxText props Map.empty value) : genBoxes es
                                             else genBoxes es
                KeyValue "open-quote"     -> case computedValue (srcProps Map.! "quotes") of
                                                ListValue lst  -> case getQuote lst of
                                                                     Just (QuoteValue str _) -> (Just $ BoxText props Map.empty str) : genBoxes es
                                                                     Nothing                 -> Nothing : genBoxes es
                                                KeyValue "none" -> (Just $ BoxText props Map.empty "\"") : genBoxes es
                KeyValue "close-quote"    -> case computedValue (srcProps Map.! "quotes") of
                                                ListValue lst  -> case getQuote lst of
                                                                     Just (QuoteValue _ str) -> (Just $ BoxText props Map.empty str) : genBoxes es
                                                                     Nothing                 -> Nothing : genBoxes es
                                                KeyValue "none" -> (Just $ BoxText props Map.empty "\"") : genBoxes es
                KeyValue "no-open-quote"  -> Nothing : genBoxes es
                KeyValue "no-close-quote" -> Nothing : genBoxes es

doIContainOnlyText [BoxText _ _ str] = (True ,str)
doIContainOnlyText _                 = (False,"error")

getAttributes (NTag _ _ ats) = ats
getAttributes _              = Map.empty

isThereBlockDisplay bx
    = case bx of
        BoxItemContainer     _ _ _ -> True
        BoxContainer _ props _ _ _ -> verifyProperty "display" "block" props
        BoxText        props _ _   -> verifyProperty "display" "block" props

-- This function build a group just for display=inline, and the others is a list of one element
funGroupCompare = (&&) `on` (\bx -> verifyProperty "display" "inline" (getProps bx))
    where getProps bx 
            = case bx of
                BoxItemContainer props _ _ -> props
                BoxContainer _ props _ _ _ -> props
                BoxText        props _ _   -> props

-- function that transform an inline element into a block container
toBoxContainer iamtheroot sprops iamreplaced lst@(bx:bxs) 
    = case bx of
        BoxItemContainer     _ _ _ -> bx
        BoxContainer _ props _ _ _ -> if verifyProperty "display" "block" props
                                      then bx
                                      else BoxContainer "inline" (applyInheritance iamtheroot propertiesCSS sprops iamreplaced) False Map.empty lst
        BoxText         props _  _ -> if verifyProperty "display" "block" props
                                      then bx
                                      else BoxContainer "inline" (applyInheritance iamtheroot propertiesCSS sprops iamreplaced) False Map.empty lst

-- this function build the specified value and the computed value
applyInheritance iamtheroot listProps fatherProps iamreplaced = 
    let inhprops              = Map.fromList (map fun listProps)
        mapWithSpecifiedValue = Map.adjust (\_ -> keyValue "block") "display" inhprops
    in Map.mapWithKey (doComputedValue iamtheroot fatherProps mapWithSpecifiedValue iamreplaced False) mapWithSpecifiedValue
    where fun (nm,inh,def) = if inh
                             then (nm, fatherProps Map.! nm)
                             else (nm, def)

}

