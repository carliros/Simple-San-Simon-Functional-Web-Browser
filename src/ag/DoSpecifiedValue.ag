
-- Attr to state who is the Root
ATTR NTree NTrees [ iamtheroot: Bool ||]
SEM Root
    | Root ntree.iamtheroot = True

SEM NTree
    | NTree ntrees.iamtheroot = False

-- build the specified value for all properties
SEM NTree
    | NTree loc.specifiedValueProps
                    = let funGenKeyValues (pn,inh,def) = (pn, doSpecifiedValue pn inh def @lhs.propsFather @lhs.iamtheroot @loc.myRuleDecls)
                      in  Map.fromList $ map funGenKeyValues propertiesCSS
            loc.specifiedContentValueProps
                    = let funGenKeyValues decl (pn,inh,def) = (pn, doSpecifiedValue pn inh def @lhs.propsFather @lhs.iamtheroot decl)
                      in  ( Map.fromList $ map (funGenKeyValues (fst @loc.myContentRules)) propertiesCSS
                          , Map.fromList $ map (funGenKeyValues (snd @loc.myContentRules)) propertiesCSS )

{
-- doSpecifiedValue, asigns an specified value to each property and receives a list of properties that match an html tag element (rules).
doSpecifiedValue :: String -> Bool -> PropertyValue -> Map.Map String PropertyValue -> Bool -> [([Selector], Property, Int)] -> PropertyValue
doSpecifiedValue    nm        inh     defval           father                          isRoot  rules
    = let lprop = getPropertyDeclarations nm rules
          rlist = head' $ dropWhile null $ cascadingSorting lprop
      in if null rlist
         then if inh && (not isRoot)
              then buildPropertyValue $ computedValue $ father Map.! nm
              else defval
         else let (_,Property _ _ val _,_,_) = head rlist
              in if compareKeyPropertyValue val "inherit"
                 then if isRoot
                      then defval
                      else buildPropertyValue $ computedValue $ father Map.! nm
                 else buildPropertyValue val 

getPropertyDeclarations prop = filter (\(_, Property _ nm _ _, _) -> nm == prop)

cascadingSorting lista1 
    = let lista2 = myZip lista1 [1..]
          lst1   = sortBy fsort $ getDeclarations User    True  lista2
          lst2   = sortBy fsort $ getDeclarations Author  True  lista2
          lst3 = sortBy fsort $ getDeclarations Author    False lista2
          lst4 = sortBy fsort $ getDeclarations User      False lista2
          lst5 = sortBy fsort $ getDeclarations UserAgent False lista2
      in [lst1, lst2 ,lst3, lst4, lst5]
    where myZip []             _      = []
          myZip ((a,b,c):next) (d:ds) = (a,b,c,d) : myZip next ds
          getDeclarations origin important = filter (\(_, Property org _ _ imp, _, _) -> origin==org && important==imp)
          fsort (_ , Property _ _ _ _, v1, v3) (_, Property _ _ _ _, v2, v4)
                |             v1 > v2 = LT
                |             v1 < v2 = GT
                | v1 == v2 && v3 > v4 = LT
                | v1 == v2 && v3 < v4 = GT
                | otherwise           = EQ

-- to test
toPrint = do let res = cascadingSorting myProps
             mapM_ (\ls -> do mapM_ (\(l,p,i,n) -> do putStr   "([], "
                                                      putStr   (show p ++ ", ")
                                                      putStr   (show i ++ ", ")
                                                      putStrLn (show n ++ ")")) ls
                              putStrLn "") res
myProps 
    = [   ([], Property Author      "a" NotSpecified True , 1)
        , ([], Property UserAgent   "b" NotSpecified False, 2)
        , ([], Property Author      "c" NotSpecified True , 3)
        , ([], Property Author      "d" NotSpecified True , 4)
        , ([], Property UserAgent   "e" NotSpecified False, 5)
        , ([], Property UserAgent   "f" NotSpecified False, 6)
        , ([], Property UserAgent   "g" NotSpecified False, 1)
        , ([], Property Author      "h" NotSpecified False, 2)
        , ([], Property Author      "i" NotSpecified False, 3)
        , ([], Property User        "j" NotSpecified False, 4)
        , ([], Property User        "k" NotSpecified False, 1)
        , ([], Property User        "l" NotSpecified False, 2)
        , ([], Property Author      "m" NotSpecified True , 3)
        , ([], Property UserAgent   "n" NotSpecified False, 4)
        , ([], Property UserAgent   "o" NotSpecified False, 5)
        ]

-- my own version of head function
head' []     = []
head' (x:xs) = x

}
