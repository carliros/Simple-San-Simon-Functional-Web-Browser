
-- counter's quotes
ATTR NTree NTrees [| quoteScope : {(Int,Int)} |]
SEM NTree
    | NTree loc.myQuoteScope  = updateQuotes @lhs.quoteScope    (fst @loc.computedContentValueProps)
            ntrees.quoteScope = @loc.myQuoteScope
            lhs.quoteScope    = updateQuotes @ntrees.quoteScope (snd @loc.computedContentValueProps)

SEM NTrees
    | Cons hd.quoteScope  = @lhs.quoteScope
           tl.quoteScope  = @hd.quoteScope
           lhs.quoteScope = @tl.quoteScope
    | Nil  lhs.quoteScope = @lhs.quoteScope

SEM Root
    | Root ntree.quoteScope = (0,0)

-- counter's scope
ATTR NTree NTrees [ | counterScope: {Map.Map String Int} | ]
SEM NTree
    | NTree loc.myCounterScope  = updateScope @lhs.counterScope @loc.computedContentValueProps @loc.computedValueProps
            ntrees.counterScope = @loc.myCounterScope
            lhs.counterScope    = @ntrees.counterScope
SEM NTrees
    | Cons hd.counterScope  = @lhs.counterScope
           tl.counterScope  = @hd.counterScope
           lhs.counterScope = @tl.counterScope
    | Nil  lhs.counterScope = @lhs.counterScope

SEM Root
    | Root ntree.counterScope = Map.empty

{
updateQuotes (open,close) props
    = let (o,c) = countQuotes $ computedValue $ props Map.! "content"
      in (open + o, close + c)
    where countQuotes valueContent
            = case valueContent of
                ListValue lst             -> foldr (\(a,b) (c,d) -> (a+c,b+d)) (0,0) $ map countQuotes lst
                KeyValue "open-quote"     -> (1,0)
                KeyValue "no-open-quote"  -> (1,0)
                KeyValue "close-quote"    -> (0,1)
                KeyValue "no-close-quote" -> (0,1)
                otherwise                 -> (0,0)

updateScope scope (propsBefore, propsAfter) props
    = let resetScope1 = resetValue scope       $ computedValue $ propsBefore Map.! "counter-reset"
          resetScope2 = resetValue resetScope1 $ computedValue $ propsAfter  Map.! "counter-reset"
          resetScope3 = resetValue resetScope2 $ computedValue $ props       Map.! "counter-reset"
          increScope1 = incrementValue resetScope3 $ computedValue $ propsBefore Map.! "counter-increment"
          increScope2 = incrementValue increScope1 $ computedValue $ propsAfter  Map.! "counter-increment"
          increScope3 = incrementValue increScope2 $ computedValue $ props       Map.! "counter-increment"
      in increScope3
    where incrementValue env vincrement
                = case vincrement of
                    KeyValue "none" -> env
                    ListValue lst   -> foldr updateIncrement env lst
               where updateIncrement (CounterValue str mb) newEnv
                        = case mb of
                            Just val -> Map.adjust (val +) str newEnv
                            Nothing  -> Map.adjust (1   +) str newEnv
          resetValue env vreset
                = case vreset of
                    KeyValue "none" -> env
                    ListValue lst   -> foldr updateReset env lst
              where updateReset (CounterValue str mb) newEnv 
                        = case mb of
                            Just val -> setup newEnv str val
                            Nothing  -> setup newEnv str 0
                    setup myMap key value 
                        = if Map.member key myMap
                          then Map.adjust (const value) key myMap
                          else Map.insert key value myMap

}
