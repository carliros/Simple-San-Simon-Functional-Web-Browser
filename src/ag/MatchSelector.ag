
imports {
import Data.Maybe
}

-- Selector's Stuff
ATTR Node [|| myself:SELF ]
ATTR NTree [|| nd:Node ]
SEM NTree
    | NTree lhs.nd = @node.myself

ATTR NTrees NTree [ fathers: {[(Node, [Node])]} ||]
SEM NTree
    | NTree ntrees.fathers = @loc.nfs : @lhs.fathers
            loc.fathers    = @lhs.fathers
            loc.nfs        = (@node.myself, @loc.siblings)

SEM Root
    | Root ntree.fathers  = []
           ntree.siblings = []

ATTR NTrees NTree [ siblings: {[Node]} ||]
SEM NTrees
    | Cons tl.siblings = @hd.nd : @lhs.siblings
           hd.siblings = @lhs.siblings

SEM NTree
    | NTree ntrees.siblings = []
            loc.siblings    = @lhs.siblings

-- build my rule declarations for each element's tree
SEM NTree
    | NTree loc.myRuleDecls    = filter (\(selectors, _, _) -> matchSelector 
                                                                    @node.myself 
                                                                    @loc.fathers 
                                                                    (reverse @loc.siblings) 
                                                                    [] 
                                                                    0 
                                                                    selectors
                                                                    False) @loc.myStyleRules
            loc.myContentRules = let list = filter (\(selectors, _, _) -> matchSelector 
                                                                            @node.myself 
                                                                            @loc.fathers 
                                                                            (reverse @loc.siblings) 
                                                                            [] 
                                                                            0 
                                                                            selectors
                                                                            True) @loc.myStyleRules
                                 in foldr funSep ([],[]) list

{-
    Un selector puede ser pseudo si solo en el subject (head de la lista) tiene un ":before" o ":after".
        ejemplo correcto  : div span p:before {...}
        ejemplo incorrecto: div:after span p  {...}

    La implementacion controla esa parte con el ultimo parametro del 'matchSelector', llamado 'verifyPseudo'
    Asi, si queremos verificar si selector es pseudo, enviamos True; con eso verificamos si el 
    subject del selector (head de la lista) es pseudo (isJust).
    Por contrario, si le enviamos False, significa que NO queremos que sea pseudo, y lo lo fuera, lo obiamos,
    osea no lo mapeamos.
    
    Resalte el 'head de la lista' por que representa el subject del selector, ya que solo el subject puede
    ser pseudo, el resto de la lista no deberia verificar el pseudo. Por eso enviamos un por defecto False
    a todo lo que no es el head de la lista.

    Nota.- El head de la lista de los selectores es el subject del selector (la lista de selectores lo invierto en el StyleProcess.ag)
-}

{
funSep ([],_,_)         (sl,sr) = (sl,sr)
funSep decl@((s:_),_,_) (sl,sr)
    = let pse = getPse s
      in case pse of
            Just PseudoBefore -> (decl : sl,        sr)
            Just PseudoAfter  -> (       sl, decl : sr)
            Nothing           -> (       sl,        sr)
    where getPse (SimpSelector ss) = getPsePse ss
          getPse (DescSelector ss) = getPsePse ss
          getPse (ChilSelector ss) = getPsePse ss
          getPse (SiblSelector ss) = getPsePse ss
          getPsePse (TypeSelector _ _ pse) = pse
          getPsePse (UnivSelector   _ pse) = pse

-- apply the list of selector to each html tag element, and returns true if the selectors apply.
matchSelector ::   Node -> [(Node,[Node])] -> [Node] -> [(Node,[Node])] -> Int -> [Selector] -> Bool -> Bool
matchSelector      _       _                  _         _                  _      []            _
    = True
matchSelector      nd      fathers            siblings  before             count  (sel:nextSel) verifyPseudo
    = case sel of
        SimpSelector s -> applySimplSelector nd fathers siblings before count s nextSel verifyPseudo
        DescSelector s -> applyDescdSelector nd fathers siblings before count s nextSel verifyPseudo
        ChilSelector s -> applyChildSelector nd fathers siblings before count s nextSel verifyPseudo
        SiblSelector s -> applySiblnSelector nd fathers siblings before count s nextSel verifyPseudo

applySimplSelector nd fathers siblings before count s nextSel verifyPseudo
    = testSimpleSelector s nd verifyPseudo && matchSelector nd fathers siblings before (count+1) nextSel False

applyDescdSelector _  []     _        _      _     _ _ _
    = False
applyDescdSelector nd (f:fs) siblings before count s nextSel verifyPseudo
    =    (testSimpleSelector s (fst f) verifyPseudo && matchSelector nd fs siblings (f:before) (count+1) nextSel False) 
      || applyDescdSelector nd fs siblings before count s nextSel False

applyChildSelector _  []     _        _      _     _ _ _
    = False
applyChildSelector nd (f:fs) siblings before count s nextSel verifyPseudo
    = testSimpleSelector s (fst f) verifyPseudo && matchSelector nd fs siblings (f:before) (count+1) nextSel False

applySiblnSelector nd fathers siblings before count s nextSel verifyPseudo
    = let brothers = if count<=1 then siblings else snd $ head before
      in let ntest = case s of
                        TypeSelector nm _ _ -> let (bool,ts) = getNextValidTag brothers
                                               in if bool
                                                  then (NTag nm False Map.empty == head ts, tail ts)
                                                  else (False, [])  -- the empty list it's not important because I won't use it any more
                        UnivSelector _ _    -> let (bool,ts) = getNextValidTag brothers
                                               in if bool
                                                  then (True, tail ts)
                                                  else (False, [])  -- the empty list it's not important because I won't use it any more
         in (fst ntest && (if count<=1
                           then matchSelector nd fathers (snd ntest) before count nextSel False
                           else matchSelector nd fathers siblings (let (f,_)=head before in (f,snd ntest): tail before) count nextSel False))

getNextValidTag []               = (False, [])
getNextValidTag l@(NTag _ _ _:_) = (True, l)
getNextValidTag (_:xs)           = getNextValidTag xs

testSimpleSelector s nd verifyPseudo
    = case s of
        TypeSelector nm1 atsel pse
            -> case nd of
                    NTag nm2 _ attrs -> let pseudoElement = if verifyPseudo
                                                            then isJust pse
                                                            else isNothing pse
                                        in if null atsel
                                           then nm1 == nm2 && pseudoElement
                                           else nm1 == nm2 && testAttributes atsel attrs && pseudoElement
                    otherwise      -> False
        UnivSelector     atsel pse
            -> case nd of
                    NTag _ _ attrs -> let pseudoElement = if verifyPseudo
                                                          then isJust pse
                                                          else isNothing pse
                                      in if null atsel
                                         then pseudoElement
                                         else testAttributes atsel attrs && pseudoElement
                    otherwise      -> False     -- I just select tag elements, i don't consider text elements
    where testAttributes []       _     
                = False
          testAttributes (at:ats) attrs 
                = case at of
                    ID  value   -> maybe False (==value) (Map.lookup value attrs)
                    ATName name -> Map.member name attrs
                    ATOperator name op value
                                -> case Map.lookup name attrs of
                                        Nothing  -> testAttributes ats attrs
                                        Just src -> case op of
                                                        "="  -> value == src
                                                        "~=" -> any (==value) $ words src


}
